# ElectionGuard Precinct Scan Implementation

## Overview

By design, the ElectionGuard SDK can be used to enable end-to-end verifiability in a variety of use cases. This article discusses the "default" use case of ElectionGuard: an end-to-end verifiable election that uses precinct scanners where ballots are inserted (and approved) by voters directly [^precinct-scan]

## Current Precinct Scan Voter Experience

A typical voter flow for a precinct scan system is illustrated below. 

After a voter has acquired their ballot, they fill it out by hand or using a ballot marking device. When they finish they proceed to the scanner and insert the completed ballot. The scanner scans and interprets the ballot and generates a [cast vote record](), an electronic representation of the voter's selections.

If all contests in a ballot are filled out properly and interpreted as such by the scanner, the ballot is accepted and the voter is free to leave the voting booth. 

If the scanner interprets the voter has voted for more options than the ballot contests allow (called an _overvote_), the scanner stops the ballot from being deposited into the ballot box and prompts the voter whether they would like to have the ballot returned to fix the discrepancy. If the voter agrees, a poll worker is alerted and the ballot remediated by whatever process obtains, which could involve issuance of a new ballot and "spoiling" of the overvoted ballot. 

The scanner can also determine whether the voter didn't fill out all the contests available (called an _undervote_). The scanner can be programmed to follow the same process as an overvote (returning the ballot for remediation), but election administrators often assume the undervote is intentional by the voter 

## Adapting Precinct Scan for End-to-end Verifiability (E2E-V)

### Voter Experience

As outlined in the Verifiable Election page of the ElectionGuard SDK [^e2e-v], for end-to-end verifiability to apply, the precinct scanner itself must provide the following capabilities for each voter:

* immediately upon scanning the ballot, create an encrypted version of the ballot using the public key generated by the election guardians (see Key Ceremony)
* the verification code generated by the encryption is presented to the voter (ideally in paper format) for the voter to take with them 
* the voter has the means to challenge (or spoil) the ballot

In this 

### Technical Requirements

For end-to-end verifiability, the scanner scanning the voters' ballots has to implement the user experience described above, but also prepare all the other artifacts

## Technical Implementation

### Overview and Operational Assumptions


### General Election Setup

#### Ballot manifest

#### Public encryption key

#### Logic and Accuracy Testing

#### Scanner Final Production Setup

##### Launch Code

### Scanner Election Operation

#### Ballot Encryption

##### Generation of Verification Code

##### Ballot Chaining

##### Ballot ***Dehydration***

### Ballot *Finalization*

#### Cast ballots

#### Challenge ballots

[^precinct-scan]: As distinct from scanners used solely for central tabulation, which occurs with mail-in voting or any tabulation / aggregation scenario *where voters are not present when the cast vote record is created*

[^e2e-v]: [ElectionGuard Verifiable Election](https://www.electionguard.vote/guide/Verifiable_Election/) [https://www.electionguard.vote/guide/Verifiable_Election/]